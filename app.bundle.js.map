{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ts/node.ts","webpack:///./src/ts/canvas.ts","webpack:///./src/ts/connection.ts","webpack:///./src/ts/index.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","Node","_x","_y","radius","color","_explicitDecay","_decayDuration","_ownConnections","_isDecaying","_isOffscreen","_opacity","this","invalidateOffScreen","list","duration","undefined","x","y","secs","updatePosition","isOffscreen","needsUpdate","forEach","conn","update","innerWidth","innerHeight","ctx","beginPath","arc","Math","PI","globalAlpha","fillStyle","fill","closePath","draw","StillNode","super","_moved","VectorNode","velocity","acceleration","reinitialize","canvas","document","querySelector","getContext","width","height","mouse","mouseDown","addEventListener","event","clientX","clientY","updaters","Set","fps","isAnimationPaused","animationWatchdog","lastTime","performance","now","animate","forceRedraw","requestAnimationFrame","t0","timeAdvance","needsRedraw","item","clearRect","elapsed","isNaN","setInterval","Connection","ownerNode","peerNode","owner","_ownerNode","_peerNode","isVisible","stroke","gradient","createLinearGradient","addColorStop","strokeStyle","lineWidth","moveTo","lineTo","isPeerDead","wasVisible","xDist","abs","yDist","distance","sqrt","pow","opacity","randomIntFromRange","min","max","floor","random","randomFromRange","fraction","div","number","node","edge","NODE_SPEED","add","_nodes","tryCreateNewNode","_mouseNode","createNode","generator","setOwnConnections","map","peer","fillText","toFixed","move","FountainNode","getRandomColor","setDecaying","RandomNode"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([8,2]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import {ICanvasElement} from \"./canvas\";\nimport {Connection} from \"./connection\";\nimport Point = paper.Point;\n\nconst NODE_DECAY_DURATION_SECONDS = 1;\nconst NODE_OPACITY_STEP = 0.5;\n\n\nexport abstract class Node implements ICanvasElement {\n    protected constructor(\n        protected _x: number,\n        protected _y: number,\n        protected radius: number,\n        public color: string\n    ) {\n        this.invalidateOffScreen();\n    }\n\n    public get x() { return this._x; }\n    public get y() { return this._y; }\n\n    private _explicitDecay = false;\n    private _decayDuration = NODE_DECAY_DURATION_SECONDS;\n    private _ownConnections: Connection[] = [];\n\n    public setOwnConnections(list: Connection[]) {\n        this._ownConnections = list;\n    }\n\n    public setDecaying(duration?: number) {\n        this._explicitDecay = true;\n        this._opacity = 1;\n        if (duration !== undefined) {\n            this._decayDuration = duration;\n        }\n    }\n\n    public reinitialize(\n        x: number,\n        y: number\n    ) {\n        this._x = x;\n        this._y = y;\n        this.invalidateOffScreen();\n    }\n\n    public update(secs: number): boolean {\n        // Update opacity gradually.\n        if (this._isDecaying) {\n            this._opacity -= secs / this._decayDuration;\n            if (this._opacity < 0) this._opacity = 0;\n        } else {\n            this._opacity += NODE_OPACITY_STEP * secs;\n            if (this._opacity >= 1) this._opacity = 1;\n        }\n\n        if ( !this.updatePosition(secs) )\n            return false;\n\n        this.invalidateOffScreen();\n\n        // Decay when going off-screen.\n        this._isDecaying = this._explicitDecay || this.isOffscreen;\n\n        // Update own connections.\n        let needsUpdate = false;\n        this._ownConnections.forEach(conn => {\n            needsUpdate = conn.update(secs) || needsUpdate;\n        });\n\n        return needsUpdate;\n    }\n\n    private invalidateOffScreen() {\n        if (this._x > innerWidth || this._x < 0) {\n            this._isOffscreen = true;\n        } else if (this._y > innerHeight || this._y < 0) {\n            this._isOffscreen = true;\n        } else\n            this._isOffscreen = false;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.arc(this._x, this._y, this.radius, 0, Math.PI * 2, false);\n        ctx.globalAlpha = this._opacity;\n        ctx.fillStyle = this.color;\n        ctx.fill();\n        ctx.closePath();\n\n        // Draw own connections.\n        this._ownConnections.forEach(conn => conn.draw(ctx));\n    }\n\n    private _isDecaying: boolean = false;\n\n    public get isOffscreen() {\n        return this._isOffscreen;\n    }\n    private _isOffscreen: boolean = false;\n\n    public get isVisible() {\n        return this._opacity > 0;\n    }\n\n    public get opacity() {\n        return this._opacity;\n    }\n    private _opacity: number = 0;\n\n    protected abstract updatePosition(secs: number): boolean;\n}\n\nexport class StillNode extends Node {\n    constructor(x: number, y: number, radius: number, color: string) {\n        super(x, y, radius, color);\n    }\n\n    protected updatePosition(secs: number): boolean {\n        if (this._moved) {\n            this._moved = false;\n            return true;\n        }\n\n        // Do nothing - it's a still node.\n        return false;\n    }\n\n    private _moved: boolean = false;\n\n    public move(x: number, y: number) {\n        this._x = x;\n        this._y = y;\n        this._moved = true;\n    }\n}\n\nexport class VectorNode extends Node {\n    constructor(\n        x: number, y: number,\n        radius: number,\n        color: string,\n        public velocity: Point,\n        public acceleration?: Point\n    ) {\n        super(x, y, radius, color);\n    }\n\n    reinitialize(x: number, y: number): void {\n        super.reinitialize(x, y);\n        this.velocity.x = 0;\n        this.velocity.y = 0;\n    }\n\n    protected updatePosition(secs: number) {\n        if (this.velocity.x === 0 && this.velocity.y === 0 && !this.acceleration)\n            return false;\n\n        if (this.acceleration) {\n            this.velocity.x += this.acceleration.x * secs;\n            this.velocity.y += this.acceleration.y * secs;\n        }\n\n        this._x += this.velocity.x * secs;\n        this._y += this.velocity.y * secs;\n        return true;\n    }\n}\n","\n// Initial Setup\nconst canvas = document.querySelector('canvas')!;\nconst ctx = canvas.getContext('2d')!;\n\ncanvas.width = innerWidth;\ncanvas.height = innerHeight;\n\n// Variables\nexport const mouse = {\n    x: -1,\n    y: -1\n};\nexport let mouseDown = false;\n\n// Event Listeners\naddEventListener('mousemove', event => {\n    mouse.x = event.clientX;\n    mouse.y = event.clientY;\n});\n\n// Event Listeners\naddEventListener('mousedown', event => {\n    mouseDown = true;\n});\n\n// Event Listeners\naddEventListener('mouseup', event => {\n    mouseDown = false;\n});\n\naddEventListener('resize', () => {\n    canvas.width = innerWidth;\n    canvas.height = innerHeight;\n});\n\nexport interface ICanvasElement {\n    update(secs: number): boolean;\n    draw(ctx: CanvasRenderingContext2D): void;\n}\n\nexport const updaters = new Set<ICanvasElement>();\n\n/// FPS avergae.\nexport let fps = 0;\nconst FPS_AVG_SAMPLES = 30;\n\nexport let isAnimationPaused = true;\nlet animationWatchdog = false;\n\nlet lastTime = performance.now();\n\n// Animation Loop\nfunction animate(forceRedraw?: boolean) {\n    requestAnimationFrame(() => animate());\n\n    animationWatchdog = false;\n\n    const t0 = performance.now();\n    let timeAdvance = t0 - lastTime;\n    lastTime = t0;\n\n    if (isAnimationPaused) {\n        isAnimationPaused = false;\n        // Reset timeadvance to prevent large lags in the animation.\n        timeAdvance = 1000 / fps;\n    }\n\n    let needsRedraw = forceRedraw;\n    updaters.forEach((item: ICanvasElement) => {\n        needsRedraw = item.update(timeAdvance / 1000) || needsRedraw;\n    });\n\n    if (needsRedraw) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        updaters.forEach((item) => {\n            item.draw(ctx);\n        });\n    }\n\n    const elapsed = performance.now() - t0;\n    const newFps = 100 / elapsed;\n\n    fps -= fps / FPS_AVG_SAMPLES;\n    fps += newFps / FPS_AVG_SAMPLES;\n\n    if (isNaN(fps))\n        fps = 0;\n    else if (fps > 60)\n        fps = 60;\n}\n\nanimate(true);\n\n// Animation watchdog.\nsetInterval(() => {\n    if (animationWatchdog) {\n        isAnimationPaused = true;\n    }\n\n    animationWatchdog = true;\n}, 200);\n","import {ICanvasElement} from \"./canvas\";\nimport {Node} from \"./node\";\n\nconst MAX_DISTANCE = 150;\n\nexport class Connection implements ICanvasElement {\n    constructor(\n        ownerNode: Node,\n        peerNode: Node,\n        width: number\n    ) {\n        this.reinitialize(ownerNode, peerNode, width);\n    }\n\n    reinitialize(\n        owner: Node,\n        peerNode: Node,\n        width: number\n    ) {\n        this._ownerNode = owner;\n        this._peerNode = peerNode;\n        this.width = width;\n        this._opacity = 0;\n    }\n\n    private _ownerNode: Node;\n    private _peerNode: Node;\n    public width: number;\n    private _opacity: number;\n\n    public get peer() { return this._peerNode; }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        if (!this.isVisible)\n            return;\n\n        let stroke;\n        if (this._ownerNode.color === this._peerNode.color) {\n            stroke = this._ownerNode.color;\n        } else {\n            const gradient = ctx.createLinearGradient(\n                this._ownerNode.x, this._ownerNode.y,\n                this._peerNode.x, this._peerNode.y\n            );\n            gradient.addColorStop(0, this._ownerNode.color);\n            gradient.addColorStop(1, this._peerNode.color);\n            stroke = gradient;\n        }\n\n        ctx.beginPath();\n        ctx.globalAlpha = this._opacity;\n        ctx.strokeStyle = stroke;\n        ctx.lineWidth = this.width;\n        ctx.moveTo(this._ownerNode.x, this._ownerNode.y);\n        ctx.lineTo(this._peerNode.x, this._peerNode.y);\n        ctx.stroke();\n        ctx.closePath();\n    }\n\n    update(secs: number): boolean {\n        if (this.isPeerDead)\n            return false;\n\n        const wasVisible = this.isVisible;\n\n        const xDist = Math.abs(this._peerNode.x - this._ownerNode.x);\n        const yDist = Math.abs(this._peerNode.y - this._ownerNode.y);\n        if (yDist >= MAX_DISTANCE || xDist >= MAX_DISTANCE) {\n            this._opacity = 0;\n        } else {\n            const distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n            if (distance >= MAX_DISTANCE) {\n                this._opacity = 0;\n            } else {\n                this._opacity = 1 - distance / MAX_DISTANCE;\n                if (this._opacity > 1) {\n                    this._opacity = 1;\n                }\n\n                // Make sure opacity correlates the nodes opacity - used for smoothing the connection in when node is added.\n                if (this._opacity > this._ownerNode.opacity) {\n                    this._opacity = this._ownerNode.opacity;\n                }\n                if (this._opacity > this._peerNode.opacity) {\n                    this._opacity = this._peerNode.opacity;\n                }\n            }\n        }\n\n        return this.isVisible || wasVisible != this.isVisible;\n    }\n\n    public get isVisible(): boolean {\n        return !this.isPeerDead && this._opacity > 0;\n    }\n\n    public get isPeerDead(): boolean {\n        return !this._peerNode.isVisible;\n    }\n}\n","import {Node, StillNode, VectorNode} from \"./node\";\nimport {fps, ICanvasElement, isAnimationPaused, mouse, mouseDown, updaters} from \"./canvas\";\nimport {Connection} from \"./connection\";\nimport { Point } from \"paper\";\n\nconst INITIAL_NODES = 300;\nconst MIN_FPS = 15;\nconst MAX_NODES = 600;\nconst NODE_SPEED = 60;\n\nfunction randomIntFromRange(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min + 1) + min)\n}\nfunction randomFromRange(min: number, max: number, fraction: number = 2) {\n    const div = Math.pow(1, fraction);\n\n    let number = 0;\n    while (number === 0)\n        number = Math.random() * div * (max - min + 1) + min * div;\n\n    number = number / div;\n\n    return number;\n}\nfunction getRandomColor() {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n        color += letters[randomIntFromRange(0, 15)];\n    }\n    return color;\n}\n\nclass NodeGenerators {\n    static StillNode(): Node {\n        return new StillNode(\n            0,\n            0,\n            2,\n            'white'\n        );\n    }\n    static EdgeNode(): Node {\n        let node: Node;\n        let x: number;\n        let y: number;\n\n        do {\n            const edge = randomIntFromRange(0, 3);\n            if (edge === 0 || edge === 1) {\n                x = edge === 0 ? 1 : innerWidth - 1;\n                y = randomFromRange(1, innerHeight - 1);\n            } else {\n                x = randomFromRange(1, innerWidth - 1);\n                y = edge === 2 ? 1 : innerHeight - 1;\n            }\n            node = new VectorNode(\n                x,\n                y,\n                2,\n                'white',\n                new Point(\n                    randomFromRange(-NODE_SPEED, NODE_SPEED),\n                    randomFromRange(-NODE_SPEED, NODE_SPEED)\n                )\n            );\n        } while (node.isOffscreen);\n\n        return node;\n    }\n    static RandomNode(): Node {\n        let node: Node;\n        let x: number;\n        let y: number;\n\n        do {\n            node = new VectorNode(\n                randomFromRange(1, innerWidth - 1),\n                randomFromRange(1, innerHeight - 1),\n                2,\n                'white',\n                new Point(\n                    randomFromRange(-NODE_SPEED, NODE_SPEED),\n                    randomFromRange(-NODE_SPEED, NODE_SPEED)\n                )\n            );\n        } while (node.isOffscreen);\n\n        return node;\n    }\n    static FountainNode(): Node {\n        let node: Node;\n        // let x: number = innerWidth / 2;\n        // let y: number = innerHeight / 2;\n        let x: number = mouse.x;\n        let y: number = mouse.y;\n\n        node = new VectorNode(\n            x,\n            y,\n            2,\n            'white',\n            new Point(\n                randomFromRange(-NODE_SPEED, NODE_SPEED)* 2,\n                randomFromRange(-NODE_SPEED, NODE_SPEED) * 2\n            ),\n            new Point(\n                randomFromRange(-NODE_SPEED, NODE_SPEED) * 2,\n                randomFromRange(-NODE_SPEED, NODE_SPEED) * 2\n            )\n        );\n\n        return node;\n    }\n    static GravityNode(): Node {\n        let node: Node;\n        // let x: number = innerWidth / 2;\n        // let y: number = innerHeight / 2;\n        let x: number = mouse.x;\n        let y: number = mouse.y;\n\n        node = new VectorNode(\n            x,\n            y,\n            2,\n            'white',\n            new Point(0, NODE_SPEED),\n            new Point(\n                randomFromRange(-10, 10),\n                randomFromRange(NODE_SPEED / 2, NODE_SPEED)\n            )\n        );\n\n        return node;\n    }\n}\n\nclass Controller implements ICanvasElement {\n    constructor() {\n        for (let i = 0; i < INITIAL_NODES; ++i) {\n            this.tryCreateNewNode();\n        }\n\n        this._mouseNode = <StillNode>this.createNode(NodeGenerators.StillNode);\n\n        // Periodically try to create nodes.\n        setInterval(() => {\n            this.tryCreateNewNode();\n        }, 50);\n    }\n\n    private createNode(generator: () => Node): Node {\n        const node = generator();\n\n        // Initialize the connections to the current existing nodes.\n        node.setOwnConnections(this._nodes.map(peer => new Connection(node, peer, 2)));\n\n        // Add to the list.\n        this._nodes.push(node);\n\n        return node;\n    }\n\n    private _mouseNode: StillNode;\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        this._nodes.forEach(item => item.draw(ctx));\n\n        ctx.globalAlpha = 1;\n        ctx.strokeStyle = 'white';\n        ctx.fillStyle = 'white';\n        ctx.fillText('Nodes: ' + this._nodes.length,0,15);\n        ctx.fillText('FPS: ' + fps.toFixed(2),0,45);\n    }\n\n    update(secs: number): boolean {\n        // Move the mouse node\n        this._mouseNode.move(mouse.x, mouse.y);\n\n        for (let i = 0; i < this._nodes.length; ++i) {\n            const node = this._nodes[i];\n            node.update(secs);\n\n            // Remove invisible nodes.\n            if (!node.isVisible && this._mouseNode != node) {\n                node.setOwnConnections([]);\n                this._nodes.splice(i, 1);\n                --i;\n            }\n        }\n\n        return true;\n    }\n\n    private _nodes: Node[] = [];\n\n    private tryCreateNewNode() {\n        if (mouseDown) {\n            const node = this.createNode(NodeGenerators.FountainNode);\n            node.color = getRandomColor();\n            node.setDecaying(randomFromRange(1, 3));\n        } else {\n            // Create \"background noise\"\n            if (\n                fps >= MIN_FPS &&\n                !isAnimationPaused &&\n                this._nodes.length < MAX_NODES\n            ) {\n                this.createNode(NodeGenerators.RandomNode);\n            }\n        }\n    }\n}\n\nupdaters.add(new Controller());\n"],"sourceRoot":""}