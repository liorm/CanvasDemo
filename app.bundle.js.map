{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ts/canvas.ts","webpack:///./src/ts/connection.ts","webpack:///./src/ts/node.ts","webpack:///./src/ts/utils.ts","webpack:///./src/ts/nodeGenerators.ts","webpack:///./src/ts/index.ts","webpack:///./src/ts/controller.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","canvas","document","querySelector","getContext","width","innerWidth","height","innerHeight","mouse","x","y","mouseDown","addEventListener","event","clientX","clientY","updaters","Set","fps","isAnimationPaused","animationWatchdog","lastTime","performance","now","animate","forceRedraw","requestAnimationFrame","t0","timeAdvance","needsRedraw","forEach","item","update","clearRect","draw","elapsed","isNaN","setInterval","Connection","ownerNode","peerNode","this","reinitialize","owner","_ownerNode","_peerNode","_opacity","ctx","isVisible","stroke","color","gradient","createLinearGradient","addColorStop","beginPath","globalAlpha","strokeStyle","lineWidth","moveTo","lineTo","closePath","secs","isPeerDead","wasVisible","xDist","Math","abs","yDist","distance","sqrt","pow","opacity","Node","_x","_y","radius","_explicitDecay","_decayDuration","_ownConnections","_isDecaying","_isOffscreen","invalidateOffScreen","list","duration","undefined","updatePosition","isOffscreen","needsUpdate","conn","arc","PI","fillStyle","fill","StillNode","super","_moved","VectorNode","velocity","acceleration","randomIntFromRange","min","max","floor","random","randomFromRange","fraction","div","number","node","edge","NODE_SPEED","add","_nodesCount","_nodes","Array","tryCreateNewNode","_mouseNode","createNode","generator","connectionsList","setOwnConnections","fillText","toFixed","move","FountainNode","getRandomColor","setDecaying","RandomNode"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([8,2]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","\n// Initial Setup\nconst canvas = document.querySelector('canvas')!;\nconst ctx = canvas.getContext('2d')!;\n\ncanvas.width = innerWidth;\ncanvas.height = innerHeight;\n\n// Variables\nexport const mouse = {\n    x: -1,\n    y: -1\n};\nexport let mouseDown = false;\n\n// Event Listeners\naddEventListener('mousemove', event => {\n    mouse.x = event.clientX;\n    mouse.y = event.clientY;\n});\n\n// Event Listeners\naddEventListener('mousedown', event => {\n    mouseDown = true;\n});\n\n// Event Listeners\naddEventListener('mouseup', event => {\n    mouseDown = false;\n});\n\naddEventListener('resize', () => {\n    canvas.width = innerWidth;\n    canvas.height = innerHeight;\n});\n\nexport interface ICanvasElement {\n    update(secs: number): boolean;\n    draw(ctx: CanvasRenderingContext2D): void;\n}\n\nexport const updaters = new Set<ICanvasElement>();\n\n/// FPS avergae.\nexport let fps = 0;\nconst FPS_AVG_SAMPLES = 30;\n\nexport let isAnimationPaused = true;\nlet animationWatchdog = false;\n\nlet lastTime = performance.now();\n\n// Animation Loop\nfunction animate(forceRedraw?: boolean) {\n    requestAnimationFrame(() => animate());\n\n    animationWatchdog = false;\n\n    const t0 = performance.now();\n    let timeAdvance = t0 - lastTime;\n    lastTime = t0;\n\n    if (isAnimationPaused) {\n        isAnimationPaused = false;\n        // Reset timeadvance to prevent large lags in the animation.\n        timeAdvance = 1000 / fps;\n    }\n\n    let needsRedraw = forceRedraw;\n    updaters.forEach((item: ICanvasElement) => {\n        needsRedraw = item.update(timeAdvance / 1000) || needsRedraw;\n    });\n\n    if (needsRedraw) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        updaters.forEach((item) => {\n            item.draw(ctx);\n        });\n    }\n\n    const elapsed = performance.now() - t0;\n    const newFps = 100 / elapsed;\n\n    fps -= fps / FPS_AVG_SAMPLES;\n    fps += newFps / FPS_AVG_SAMPLES;\n\n    if (isNaN(fps))\n        fps = 0;\n    else if (fps > 60)\n        fps = 60;\n}\n\nanimate(true);\n\n// Animation watchdog.\nsetInterval(() => {\n    if (animationWatchdog) {\n        isAnimationPaused = true;\n    }\n\n    animationWatchdog = true;\n}, 200);\n","import {ICanvasElement} from \"./canvas\";\nimport {Node} from \"./node\";\n\nconst MAX_DISTANCE = 150;\n\nexport class Connection implements ICanvasElement {\n    constructor(\n        ownerNode: Node,\n        peerNode: Node,\n        width: number\n    ) {\n        this.reinitialize(ownerNode, peerNode, width);\n    }\n\n    reinitialize(\n        owner: Node,\n        peerNode: Node,\n        width: number\n    ) {\n        this._ownerNode = owner;\n        this._peerNode = peerNode;\n        this.width = width;\n        this._opacity = 0;\n    }\n\n    private _ownerNode: Node;\n    private _peerNode: Node;\n    public width: number;\n    private _opacity: number;\n\n    public get peer() { return this._peerNode; }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        if (!this.isVisible)\n            return;\n\n        let stroke;\n        if (this._ownerNode.color === this._peerNode.color) {\n            stroke = this._ownerNode.color;\n        } else {\n            const gradient = ctx.createLinearGradient(\n                this._ownerNode.x, this._ownerNode.y,\n                this._peerNode.x, this._peerNode.y\n            );\n            gradient.addColorStop(0, this._ownerNode.color);\n            gradient.addColorStop(1, this._peerNode.color);\n            stroke = gradient;\n        }\n\n        ctx.beginPath();\n        ctx.globalAlpha = this._opacity;\n        ctx.strokeStyle = stroke;\n        ctx.lineWidth = this.width;\n        ctx.moveTo(this._ownerNode.x, this._ownerNode.y);\n        ctx.lineTo(this._peerNode.x, this._peerNode.y);\n        ctx.stroke();\n        ctx.closePath();\n    }\n\n    update(secs: number): boolean {\n        if (this.isPeerDead)\n            return false;\n\n        const wasVisible = this.isVisible;\n\n        const xDist = Math.abs(this._peerNode.x - this._ownerNode.x);\n        const yDist = Math.abs(this._peerNode.y - this._ownerNode.y);\n        if (yDist >= MAX_DISTANCE || xDist >= MAX_DISTANCE) {\n            this._opacity = 0;\n        } else {\n            const distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n            if (distance >= MAX_DISTANCE) {\n                this._opacity = 0;\n            } else {\n                this._opacity = 1 - distance / MAX_DISTANCE;\n                if (this._opacity > 1) {\n                    this._opacity = 1;\n                }\n\n                // Make sure opacity correlates the nodes opacity - used for smoothing the connection in when node is added.\n                if (this._opacity > this._ownerNode.opacity) {\n                    this._opacity = this._ownerNode.opacity;\n                }\n                if (this._opacity > this._peerNode.opacity) {\n                    this._opacity = this._peerNode.opacity;\n                }\n            }\n        }\n\n        return this.isVisible || wasVisible != this.isVisible;\n    }\n\n    public get isVisible(): boolean {\n        return !this.isPeerDead && this._opacity > 0;\n    }\n\n    public get isPeerDead(): boolean {\n        return !this._peerNode.isVisible;\n    }\n}\n","import {ICanvasElement} from \"./canvas\";\nimport {Connection} from \"./connection\";\nimport Point = paper.Point;\n\nconst NODE_DECAY_DURATION_SECONDS = 1;\nconst NODE_OPACITY_STEP = 0.5;\n\n\nexport abstract class Node implements ICanvasElement {\n    protected constructor(\n        protected _x: number,\n        protected _y: number,\n        protected radius: number,\n        public color: string\n    ) {\n        this.invalidateOffScreen();\n    }\n\n    public get x() { return this._x; }\n    public get y() { return this._y; }\n\n    private _explicitDecay = false;\n    private _decayDuration = NODE_DECAY_DURATION_SECONDS;\n    private _ownConnections: Connection[] = [];\n\n    public setOwnConnections(list: Connection[]) {\n        this._ownConnections = list;\n    }\n\n    public setDecaying(duration?: number) {\n        this._explicitDecay = true;\n        this._opacity = 1;\n        if (duration !== undefined) {\n            this._decayDuration = duration;\n        }\n    }\n\n    public reinitialize(\n        x: number,\n        y: number\n    ) {\n        this._x = x;\n        this._y = y;\n        this.invalidateOffScreen();\n    }\n\n    public update(secs: number): boolean {\n        // Update opacity gradually.\n        if (this._isDecaying) {\n            this._opacity -= secs / this._decayDuration;\n            if (this._opacity < 0) this._opacity = 0;\n        } else {\n            this._opacity += NODE_OPACITY_STEP * secs;\n            if (this._opacity >= 1) this._opacity = 1;\n        }\n\n        if ( !this.updatePosition(secs) )\n            return false;\n\n        this.invalidateOffScreen();\n\n        // Decay when going off-screen.\n        this._isDecaying = this._explicitDecay || this.isOffscreen;\n\n        // Update own connections.\n        let needsUpdate = false;\n        this._ownConnections.forEach(conn => {\n            needsUpdate = conn.update(secs) || needsUpdate;\n        });\n\n        return needsUpdate;\n    }\n\n    private invalidateOffScreen() {\n        if (this._x > innerWidth || this._x < 0) {\n            this._isOffscreen = true;\n        } else if (this._y > innerHeight || this._y < 0) {\n            this._isOffscreen = true;\n        } else\n            this._isOffscreen = false;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.arc(this._x, this._y, this.radius, 0, Math.PI * 2, false);\n        ctx.globalAlpha = this._opacity;\n        ctx.fillStyle = this.color;\n        ctx.fill();\n        ctx.closePath();\n\n        // Draw own connections.\n        this._ownConnections.forEach(conn => conn.draw(ctx));\n    }\n\n    private _isDecaying: boolean = false;\n\n    public get isOffscreen() {\n        return this._isOffscreen;\n    }\n    private _isOffscreen: boolean = false;\n\n    public get isVisible() {\n        return this._opacity > 0;\n    }\n\n    public get opacity() {\n        return this._opacity;\n    }\n    private _opacity: number = 0;\n\n    protected abstract updatePosition(secs: number): boolean;\n}\n\nexport class StillNode extends Node {\n    constructor(x: number, y: number, radius: number, color: string) {\n        super(x, y, radius, color);\n    }\n\n    protected updatePosition(secs: number): boolean {\n        if (this._moved) {\n            this._moved = false;\n            return true;\n        }\n\n        // Do nothing - it's a still node.\n        return false;\n    }\n\n    private _moved: boolean = false;\n\n    public move(x: number, y: number) {\n        this._x = x;\n        this._y = y;\n        this._moved = true;\n    }\n}\n\nexport class VectorNode extends Node {\n    constructor(\n        x: number, y: number,\n        radius: number,\n        color: string,\n        public velocity: Point,\n        public acceleration?: Point\n    ) {\n        super(x, y, radius, color);\n    }\n\n    reinitialize(x: number, y: number): void {\n        super.reinitialize(x, y);\n        this.velocity.x = 0;\n        this.velocity.y = 0;\n    }\n\n    protected updatePosition(secs: number) {\n        if (this.velocity.x === 0 && this.velocity.y === 0 && !this.acceleration)\n            return false;\n\n        if (this.acceleration) {\n            this.velocity.x += this.acceleration.x * secs;\n            this.velocity.y += this.acceleration.y * secs;\n        }\n\n        this._x += this.velocity.x * secs;\n        this._y += this.velocity.y * secs;\n        return true;\n    }\n}\n","\nexport function randomIntFromRange(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\nexport function randomFromRange(min: number, max: number, fraction: number = 2) {\n    const div = Math.pow(1, fraction);\n\n    let number = 0;\n    while (number === 0)\n        number = Math.random() * div * (max - min + 1) + min * div;\n\n    number = number / div;\n\n    return number;\n}\n\nexport function getRandomColor() {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n        color += letters[randomIntFromRange(0, 15)];\n    }\n    return color;\n}\n\n","import {Node, StillNode, VectorNode} from \"./node\";\nimport {Point} from \"paper\";\nimport {mouse} from \"./canvas\";\nimport {randomFromRange, randomIntFromRange} from \"./utils\";\n\nconst NODE_SPEED = 60;\n\nexport class NodeGenerators {\n    static StillNode(): Node {\n        return new StillNode(\n            0,\n            0,\n            2,\n            'white'\n        );\n    }\n\n    static EdgeNode(): Node {\n        let node: Node;\n        let x: number;\n        let y: number;\n\n        do {\n            const edge = randomIntFromRange(0, 3);\n            if (edge === 0 || edge === 1) {\n                x = edge === 0 ? 1 : innerWidth - 1;\n                y = randomFromRange(1, innerHeight - 1);\n            } else {\n                x = randomFromRange(1, innerWidth - 1);\n                y = edge === 2 ? 1 : innerHeight - 1;\n            }\n            node = new VectorNode(\n                x,\n                y,\n                2,\n                'white',\n                new Point(\n                    randomFromRange(-NODE_SPEED, NODE_SPEED),\n                    randomFromRange(-NODE_SPEED, NODE_SPEED)\n                )\n            );\n        } while (node.isOffscreen);\n\n        return node;\n    }\n\n    static RandomNode(): Node {\n        let node: Node;\n        let x = randomFromRange(1, innerWidth - 1);\n        let y = randomFromRange(1, innerHeight - 1);\n\n        do {\n            node = new VectorNode(\n                x,\n                y,\n                2,\n                'white',\n                new Point(\n                    randomFromRange(-NODE_SPEED, NODE_SPEED),\n                    randomFromRange(-NODE_SPEED, NODE_SPEED)\n                )\n            );\n        } while (node.isOffscreen);\n\n        return node;\n    }\n\n    static FountainNode(): Node {\n        let node: Node;\n        // let x: number = innerWidth / 2;\n        // let y: number = innerHeight / 2;\n        let x: number = mouse.x;\n        let y: number = mouse.y;\n\n        node = new VectorNode(\n            x,\n            y,\n            2,\n            'white',\n            new Point(\n                randomFromRange(-NODE_SPEED * 2, NODE_SPEED * 2),\n                randomFromRange(-NODE_SPEED * 3, -NODE_SPEED * 2)\n            ),\n            new Point(\n                0,\n                randomFromRange(NODE_SPEED, NODE_SPEED * 2)\n            )\n        );\n\n        return node;\n    }\n\n    static GravityNode(): Node {\n        let node: Node;\n        // let x: number = innerWidth / 2;\n        // let y: number = innerHeight / 2;\n        let x: number = mouse.x;\n        let y: number = mouse.y;\n\n        node = new VectorNode(\n            x,\n            y,\n            2,\n            'white',\n            new Point(0, NODE_SPEED),\n            new Point(\n                randomFromRange(-10, 10),\n                randomFromRange(NODE_SPEED / 2, NODE_SPEED)\n            )\n        );\n\n        return node;\n    }\n}\n","import {updaters} from \"./canvas\";\nimport {Controller} from \"./controller\";\n\nupdaters.add(new Controller());\n","import {Node, StillNode} from \"./node\";\nimport {fps, ICanvasElement, isAnimationPaused, mouse, mouseDown} from \"./canvas\";\nimport {Connection} from \"./connection\";\nimport {NodeGenerators} from \"./nodeGenerators\";\nimport {getRandomColor, randomFromRange} from \"./utils\";\n\nconst INITIAL_NODES = 300;\nconst MIN_FPS = 15;\nconst MAX_NODES = 600;\n\nexport class Controller implements ICanvasElement {\n    constructor() {\n        for (let i = 0; i < INITIAL_NODES; ++i) {\n            this.tryCreateNewNode();\n        }\n\n        this._mouseNode = <StillNode>this.createNode(NodeGenerators.StillNode);\n\n        // Periodically try to create nodes.\n        setInterval(() => {\n            this.tryCreateNewNode();\n        }, 50);\n    }\n\n    private createNode(generator: () => Node): Node {\n        const node = generator();\n\n        // Initialize the connections to the current existing nodes.\n        const connectionsList = new Array<Connection>(this._nodesCount);\n        for (let i = 0; i < this._nodesCount; ++i)\n            connectionsList[i] = new Connection(node, this._nodes[i], 2);\n        node.setOwnConnections(connectionsList);\n\n        // Add to the list.\n        this._nodes[this._nodesCount] = node;\n        ++this._nodesCount;\n\n        return node;\n    }\n\n    private _mouseNode: StillNode;\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        for (let i = 0; i < this._nodesCount; ++i)\n            this._nodes[i].draw(ctx);\n\n        ctx.globalAlpha = 1;\n        ctx.strokeStyle = 'white';\n        ctx.fillStyle = 'white';\n        ctx.fillText('Nodes: ' + this._nodesCount,0,15);\n        ctx.fillText('FPS: ' + fps.toFixed(2),0,45);\n    }\n\n    update(secs: number): boolean {\n        // Move the mouse node\n        this._mouseNode.move(mouse.x, mouse.y);\n\n        for (let i = 0; i < this._nodesCount; ++i) {\n            const node = this._nodes[i];\n            node.update(secs);\n\n            // Remove invisible nodes.\n            if (!node.isVisible && this._mouseNode != node) {\n                node.setOwnConnections([]);\n\n                if (this._nodesCount > 1) {\n                    this._nodes[i] = this._nodes[this._nodesCount - 1];\n                }\n                --this._nodesCount;\n                --i;\n            }\n        }\n\n        return true;\n    }\n\n    private _nodesCount = 0;\n    private _nodes: Node[] = new Array<Node>(MAX_NODES);\n\n    private tryCreateNewNode() {\n        if (mouseDown) {\n            const node = this.createNode(NodeGenerators.FountainNode);\n            node.color = getRandomColor();\n            node.setDecaying(randomFromRange(2, 5));\n        } else {\n            // Create \"background noise\"\n            if (\n                fps >= MIN_FPS &&\n                !isAnimationPaused &&\n                this._nodesCount < MAX_NODES\n            ) {\n                this.createNode(NodeGenerators.RandomNode);\n            }\n        }\n    }\n}\n"],"sourceRoot":""}